# -*- coding: utf-8 -*-
"""Nuevo Actividad3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ps3sHYgFo3brUPoDEZlinhiZ6YgQNkrx
"""

#!pip install treelib
import random
import math
import numpy as np
import matplotlib.pyplot as plt
import time
import platform   #Para determinar al arquitectura del ordenador
from treelib import Node, Tree
from sklearn.metrics import mean_squared_error, mean_absolute_error

def esNumerico(cadena):
  cadena=str(cadena)
  if len(cadena)>0:
    if cadena[0]=="-":
      cadena=cadena[1:]

  exp=False

  if 'e' in cadena:
    divisor='e'
    exp=True
  elif 'E' in cadena:
    divisor='E'
    exp=True

  if exp:
    x=cadena.split(divisor)
    
    if len(x)==2:
      if x[1][0]=="-" or x[1][0]=="+":
        x[1]=x[1][1:]
      if x[1].isdigit():
        cadena=x[0]
      else:
        return False
    else:
      return False

  n = cadena.replace('.', '', 1).isdigit()
  return n


def divisionProtegida(numerador,divisor):
  
  if divisor==.0:
      if numerador==.0:
        return np.nan
      else:
        bits=""
        for i in platform.architecture()[0]:
          if i.isnumeric():
            bits+=i

        bitsN=int(bits)
        mayorNum=2**(bitsN-1)-1
        return mayorNum
  else:
      return numerador/divisor

def potenciaProtegida(radicando, potencia):

  try:
    resultado=radicando**potencia
  except:
    bits=""

    for i in platform.architecture()[0]:
      if i.isnumeric():
        bits+=i

    bitsN=int(bits)
    resultado=2**(bitsN-1)-1

  if (isinstance(resultado,complex)):
    return resultado.real
  else:
    return resultado

def rGenKG():
  w=np.random.uniform(low=0, high=1)
  Y=np.random.uniform(low=0, high=9)
  C=np.random.uniform(low=0, high=9)
  return "[KG,"+str(w)+","+str(Y)+","+str(C)+"]"

def rGenKP():
  w=np.random.uniform(low=0, high=1)
  A=np.random.uniform(low=0, high=9)
  B=np.random.uniform(low=0, high=9)
  d=np.random.randint(9)
  return "[KP,"+str(w)+","+str(A)+","+str(B)+","+str(d)+"]"

def rGenKS():
  w=np.random.uniform(low=0, high=1)
  D=np.random.uniform(low=0, high=9)
  O=np.random.uniform(low=0, high=9)
  return "[KS,"+str(w)+","+str(D)+","+str(O)+"]"


def calKG(w,Y,C,X):
  return w*np.exp(-Y*(C-X)**2)

def calKP(w,A,B,d,X):
  return w*((A*X+B)**d)

def calKS(w,D,O,X):
  return w*(np.tanh(D*X+O))

def fenotipo(ptos1, ptos2, tipo):
  if tipo==1:
    return np.sqrt(np.square(np.subtract(ptos1,ptos2)).mean())
  elif tipo==2:
    return np.square(np.subtract(ptos1,ptos2)).mean()
  elif tipo==3:
    return np.abs(np.subtract(ptos1,ptos2)).mean()

def genKernel(terminal):
  if terminal =='KG':
    return rGenKG()
  elif terminal=='KP':
    return rGenKP()
  elif terminal=='KS':
    return rGenKS()

def genRamasNivel(Nivel, operadores, terminales, tipo):
  #si tipo=1 crecimiento uniforme
  #si tipo=2 crecimiento mixto
  
  i=0
  
  individuo_aux=[]
  dim=1
  while i<Nivel:
    i+=1
    cada_nivel=[]
    if i==Nivel:
        for j in range(2*dim):
          terminal=np.random.choice(terminales)
          if terminal in ['KG','KP','KS']:
            terminal=genKernel(terminal)
          cada_nivel.append(terminal)
    else:
      if i==1:
        operador=np.random.choice(operadores)
        cada_nivel.append(operador)
        restDim=0
      else:
        restDim=0
        for j in range(dim):
          operador=np.random.choice(operadores)
          cada_nivel.append(operador)

          if tipo==2:
            siTerminal = bool(random.getrandbits(1))

            if siTerminal:
              terminal=np.random.choice(terminales)
              if terminal in ['KG','KP','KS']:
                terminal=genKernel(terminal)

              cada_nivel.append(terminal)
              restDim+=1
            else:
              operador=np.random.choice(operadores)
              cada_nivel.append(operador)
          else:
              operador=np.random.choice(operadores)
              cada_nivel.append(operador)           
        
        dim=2*dim-restDim

    individuo_aux.append(cada_nivel)

  return individuo_aux

def generarIndividuo(Niv1, Niv2, operadores, terminales, tipo):

  individuo_total=[]
  individuo_total.append(np.random.choice(operadores))

  individuo_total.append(genRamasNivel(Niv1, operadores, terminales, tipo))
  individuo_total.append(genRamasNivel(Niv2, operadores, terminales, tipo))

 
  return individuo_total

def operacion(operador, num1, num2):
  if esNumerico(num1) and esNumerico(num2):
    if (operador=='/'):
      return str(divisionProtegida(float(num1),float(num2)))
    elif (operador=="+"):
      return str(float(num1)+float(num2))
    elif (operador=="-"):
      return str(float(num1)-float(num2))
    elif (operador=="*"):
      return str(float(num1)*float(num2))
    elif (operador=="^"):
      return str(potenciaProtegida(float(num1),float(num2)))
  else:
    return str(num1)+operador+str(num2)

def generarFuncion(individuo,operadores):
  Nivel1=len(individuo[1])
  Nivel2=len(individuo[2])

  nivel1=individuo[1][Nivel1-1]
  nivel2=individuo[2][Nivel2-1]

  for i in reversed(range(Nivel1-1)):
    niv_aux=[]
    ind=0

    for j in individuo[1][i]:  
      if j in operadores:
        resultado="("+operacion(j,nivel1[ind],nivel1[ind+1])+")"
        ind+=2
      else:
        resultado="("+str(j)+")"
      niv_aux.append(resultado)

    nivel1=niv_aux

  for i in reversed(range(Nivel2-1)):
    niv_aux=[]
    ind=0

    for j in individuo[2][i]:  
      if j in operadores:
        resultado="("+operacion(j,nivel2[ind],nivel2[ind+1])+")"
        ind+=2
      else:
        resultado="("+str(j)+")"
      niv_aux.append(resultado)

    nivel2=niv_aux
  return([individuo[0],nivel1,nivel2])

def dibujarArbol(individuo, terminales):

  arbol = Tree()
  id=0
  padres=[]
  Niveles=len(individuo[1])

  arbol.create_node(individuo[0],"-1")

  for i in range(Niveles):
    if i==0:
      padres.append(str(id))
      arbol.create_node(individuo[1][0][0],str(id), parent="-1")
    else:
      chivato=0
      padres_aux=[]
      padre=0
      for j in range(len(individuo[1][i])):
        if chivato==2:
          chivato=0
          padre+=1
        id+=1
        if individuo[1][i][j] not in terminales:
          padres_aux.append(str(id))
        arbol.create_node(individuo[1][i][j], str(id), parent=padres[padre])
        chivato+=1
      padres=padres_aux
  
  padres=[]
  Niveles=len(individuo[2])
  id+=1

  for i in range(Niveles):
    if i==0:
      padres.append(str(id))
      arbol.create_node(individuo[2][0][0],str(id), parent="-1")
    else:
      chivato=0
      padres_aux=[]
      padre=0
      for j in range(len(individuo[2][i])):
        if chivato==2:
          chivato=0
          padre+=1
        id+=1
        if individuo[2][i][j] not in terminales:
          padres_aux.append(str(id))
        arbol.create_node(individuo[2][i][j], str(id), parent=padres[padre])
        chivato+=1
      padres=padres_aux

  arbol.show()

def indiceElemento(cadena, elemento, posicion=0):
  try:
    return cadena.index(elemento,posicion)
  except:
    return -1

def esKernel(parte):
  if "KG" in str(parte) or "KP" in str(parte) or "KS" in str(parte):
    return True
  return False

def tratarKernel(X, parte):
   while "[" in parte:
      ini=parte.index("[")
      fin=parte.index("]")

      kernel=parte[ini:fin]
      divParam=kernel.split(",")
      divParam[len(divParam)-1]=divParam[len(divParam)-1].split("]")[0]
      
      if "KG" in divParam[0]:
        valor = calKG(float(divParam[1]),float(divParam[2]),float(divParam[3]),float(X))
      if "KP" in divParam[0]:
        valor = calKP(float(divParam[1]),float(divParam[2]),float(divParam[3]),float(divParam[4]),float(X))
      if "KS" in divParam[0]:
        valor = calKS(float(divParam[1]),float(divParam[2]),float(divParam[3]),float(X))

      parte=parte[0:ini]+str(valor)+parte[fin+1:]
   return parte

def tratarParteFuncion(parte, operadores,X):
  fin=False
  parte_aux=""
  partes=[]

  if esNumerico(parte):
    return parte

  indP=[]
  indMD=[]
  indSR=[]

  contador=0
  parteA=''
  for i in range(len(parte)):
    if parte[i] not in operadores or i==0 or parte[i] in ['e','E']:
      parte_aux=parte_aux+parte[i]
    else:
      if parte[i] in ['+','-']:
        if parte[i-1] in ['e','E'] or parte[i-1] in operadores:
          parte_aux=parte_aux+parte[i]
        else:
          if parte_aux!="":
            partes.append(parte_aux)
          contador+=1
          parte_aux=""
          partes.append(parte[i])
          indSR.append(contador)
          contador+=1
      else:
        if parte_aux!="":
          partes.append(parte_aux)
        contador+=1
        parte_aux=""
        partes.append(parte[i])
        if parte[i]=='^':
          indP.append(contador)
        elif parte[i] in ['*','/']:
          indMD.append(contador)
        elif parte[i] in ['+','-']:
          indSR.append(contador)
        contador+=1
    parteA=parte[i]

  if parte_aux!="":
    partes.append(parte_aux)
  

  #print("Esta: ",partes)

  i=0
  while i < len(partes)-1:
    if i+1 in indP:
      if (esNumerico(partes[i]) or partes[i]=='X') and (esNumerico(partes[i+2]) or partes[i+2]=='X'):
        
        if partes[i]=='X':
          partes[i]=X
        
        if partes[i+2]=='X':
          partes[i+2]=X

        resultado=potenciaProtegida(float(partes[i]),float(partes[i+2]))
        partes[i]=resultado


        for j in range(len(indMD)):
          if indMD[j]>indP[0]:
            indMD[j]=indMD[j]-2

        for j in range(len(indSR)):
          if indSR[j]>indP[0]:
            indSR[j]=indSR[j]-2 

        del partes[i+1]
        del partes[i+1]
        indP = list(map(lambda x: x - 2, indP))
        del indP[0]
      i-=1
    i+=1

  #print("Esta2: ",partes)
  i=0
  while i < len(partes)-1:
    if i+1 in indMD:
      if (esNumerico(partes[i]) or partes[i]=='X') and (esNumerico(partes[i+2]) or partes[i+2]=='X'):
        if partes[i]=='X':
          partes[i]=X
        
        if partes[i+2]=='X':
          partes[i+2]=X


        if partes[i+1]=='*':
          resultado=float(partes[i])*float(partes[i+2])
        else:
          resultado=divisionProtegida(float(partes[i]),float(partes[i+2]))
        
        partes[i]=resultado

        for j in range(len(indSR)):
          if indSR[j]>indMD[0]:
            indSR[j]=indSR[j]-2 

        del partes[i+1]
        del partes[i+1]
        indMD = list(map(lambda x: x - 2, indMD))
        del indMD[0]
      i-=1
    i+=1

  #print("Esta3: ",partes)
  i=0

  while i < len(partes)-1:
    if i+1 in indSR:
      if (esNumerico(partes[i]) or partes[i]=='X') and (esNumerico(partes[i+2]) or partes[i+2]=='X'):
        if partes[i]=='X':
          partes[i]=X
        
        if partes[i+2]=='X':
          partes[i+2]=X

        if partes[i+1]=='+':
          resultado=float(partes[i])+float(partes[i+2])
        else:
          resultado=float(partes[i])-float(partes[i+2])

        partes[i]=resultado

        del partes[i+1]
        del partes[i+1]
        indSR = list(map(lambda x: x - 2, indSR))
        del indSR[0]
      i-=1
    i+=1
  return partes[0]
  #print("Esta3: ",partes)


def PuntosYfuncion(funcion, puntosX):
  puntosY=[]

  for j in puntosX:
    if funcion.count("(") == funcion.count(")"):
      funcion_aux=funcion
      i=0
      while "(" in funcion_aux:
        parentesis = False
        indFin=0

        if (funcion_aux[i]=="("):
          parte=""
          indIni=i
        elif (funcion_aux[i]==")"):
          indFin=i
        else:
          parte=parte+funcion_aux[i]
              
        if indFin>0:
          parte1=funcion_aux[:indIni]
          parte2=funcion_aux[indFin+1:]
          if esKernel(parte):
            parte=tratarKernel(j,parte)
          funcion_aux=parte1+str(tratarParteFuncion(parte,Operadores,j))+parte2 

          i=-1
        i+=1
    else:
      print("La función no está representada correctamente")
    
    puntosY.append(funcion_aux)

  return (puntosY)

def GenerarPtosYFunc(funcionT, puntosX):
  fun_aux=funcionT.copy()

  opP=funcionT[0]

  del fun_aux[0]
  puntoYparte=[]
  
  for i in fun_aux:
    puntoYparte.append(PuntosYfuncion(i[0],puntosX))

  if opP=='/':
    for i in range(len (puntoYparte[0])):
     puntoYparte[0][i]=divisionProtegida(float(puntoYparte[0][i]),float(puntoYparte[1][i]))
  elif opP=='^':
    for i in range(len (puntoYparte[0])):
     puntoYparte[0][i]=potenciaProtegida(float(puntoYparte[0][i]),float(puntoYparte[1][i]))
  elif opP=='*':
    for i in range(len (puntoYparte[0])):
     puntoYparte[0][i]=float(puntoYparte[0][i])*float(puntoYparte[1][i])
  elif opP=='+':
    for i in range(len (puntoYparte[0])):
     puntoYparte[0][i]=float(puntoYparte[0][i])+float(puntoYparte[1][i])
  elif opP=='-':
    for i in range(len (puntoYparte[0])):
     puntoYparte[0][i]=float(puntoYparte[0][i])-float(puntoYparte[1][i])

  return puntoYparte[0]

def darError(vector1, vector2, tipo):
  if tipo==1:
    #RMSE
    return mean_squared_error(vector1, vector2, squared=False)
  elif tipo==2:
    #MSE
    return mean_squared_error(vector1, vector2, squared=True)
  elif tipo==3:
    #MSA
    return mean_absolute_error(vector1, vector2)


def generarPtosIniciales(tipoF, dom, tam):
  equis=[]
  intervalo=(dom[1]-dom[0])/(tam-1)

  equis.append(dom[0])
  for i in range(1,tam):
    equis.append(equis[i-1]+intervalo)
  
  Fx=[]

  if tipoF==1:
    for i in equis:
      Fx.append((8*np.exp(-2*(i-2)**2))+(2*i+1)+(3*np.tanh(3*i+2)))
  elif tipoF==2:
    for i in equis:
      Fx.append((2*np.exp(-2*(i-1)**2))-np.exp(-(i-1)**2))
  elif tipoF==3:
    for i in equis:
      Fx.append(np.sqrt(i))
  elif tipoF==4:
    for i in equis:
      Fx.append(np.exp(-1*i)*np.sin(2*i))

  return (equis,Fx)


valXYfunc=[]
valXYfunc.append(generarPtosIniciales(1,[-2,4],100))
valXYfunc.append(generarPtosIniciales(2,[-1,3],100))
valXYfunc.append(generarPtosIniciales(3,[0,4],100))
valXYfunc.append(generarPtosIniciales(4,[0,4],100))

plt.plot(valXYfunc[0][0],valXYfunc[0][1])
plt.legend(['Función Problema 1'])
plt.xlabel("x")
plt.ylabel("f(x)")
plt.show()
plt.close()

plt.plot(valXYfunc[1][0],valXYfunc[1][1])
plt.legend(['Función Problema 2'])
plt.xlabel("x")
plt.ylabel("f(x)")
plt.show()
plt.close()

plt.plot(valXYfunc[2][0],valXYfunc[2][1])
plt.legend(['Función Problema 3'])
plt.xlabel("x")
plt.ylabel("f(x)")
plt.show()
plt.close()

plt.plot(valXYfunc[3][0],valXYfunc[3][1])
plt.legend(['Función Problema 4'])
plt.xlabel("x")
plt.ylabel("f(x)")
plt.show()
plt.close()


#Se definen los terminales y los operadores

Terminales=['KG','KP','KS']
Operadores=['+','-']

#############################################################################################
###  EXPLICACIÓN FUNCIONAMIENTO DE LA 1º PARTE DEL PROGRAMA                               ###
#############################################################################################

#Esto es un ejemplo para un individo. Para generar un individuo (una función), pirmeramente se 
#elgie los niveles máximo por cada rama principal del arbol que representa la función, es decir,
#si yo marco como nivel max1 2 (NivelR1=2), pues se generan nє[1,2] nieveles por 
#esa rama elegido n de forma aleatoria y un nivel max2 de 3 (NivelR2=3), eleigira nє[1,3] 
#nieveles por la segunda rama, elegido n de forma aleatoria. Así si queremos generar una 
#función con estas opciones: Terminales=['X','5','8',"3"] y los operadores de la función serían:
#Operadores=['+','-','^','*','/'], le pasamos  esos datos a la generación de 
#crear un invidiuo: ind=generarIndividuo(NivelR1, NivelR2, Operadores, Terminales, tipo)
#el tipo se refiere al tipo de crecimiento, en este caso tipo=1 (crecimiento uniforme) (terminales solo 
#al final del arbol). A partir de este individuo podemos dibujar su arbol con la función dibjuarArbol, 
#pasándole el individuo y los terminales: dibujarArbol(ind,Terminales) y mostrará algo como esto:
#
#  Crecimiento uniforme                                         Crecimiento mixto
#  ^                                                                    *
#  ├── *                                                                ├── /
#  │   ├── +                                                            │   ├── 3
#  │   │   ├── 5                                                        │   │  
#  │   │   └── 5                                                        │   └──+ 
#  │   └── -                                                            │      ├──X
#  │       ├── 8                                                        │      └──5
#  │       └── X                                                        └── -
#  └── +                                                                    ├── 3
#      ├── 8                                                                └── 5
#      └── X
#
# El caso anterior es eligiendo una profunidad de nodo 2,3 para cada rama, se podía haber elegido la
# misma profundidad.
# El nodo raiz es una operación elegida al azar y los sucesivos nodos igual hasta llegar a los
# terminales, ahora si queremos representar esta función con paréntesis lo podemos realizar con la
# función funcion=generarFuncion(ind,Operadores) y sacarla por pantalla print(funcion), que nos dará
# lo siguiente para el primer árbol: ['^', ['(8+X)'], ['((10.0)*(X-8))']], como puede verse, es 
# la función ya simplificada mostrada en el árbol, sería la siguiente función: f(x)=(8+X)**(10*(X-8)), 
# que es realmente el  individuo y es la forma que se ha elegido para representarlo. Ahora si queremos 
# obtener valores f(X) en función de valores de X, lo que hacemos es pasarle esa función y un vector de 
# X a la función  GenerarPtosYFunc(funcion, [0,1,2,3,4,5,6]), y generara un vector de puntos f(X) como se muestra:
#[5.6597994242e-73, 1.5959685878e-67, 1e-60, 8.518551279e-53, 6.8037783679e-44, 3.81680023943e-34, 1.19519642774e-23]

#Ahora, se han definido como terminales,'KG','KP','KS', en el que se generan los parámetros P y W de 
#forma aleatoria para un kernel gaussiano (KG), un kernel polinómico (KP) o un kernel sigmoide (KS), y se 
#calucla el valor de esos kernels para un valor de X dado. Como la actividad pide que se ajuste funciones solo 
#a sumatorios de gaussianas, funciones polinómicas y funciones sigmoide, como operradores solo se dejará la
#suma y la resta: 

Operadores=['+','-']

#Y como terminales serían solo las funciones dadas, hay que decir, que para las funciones dadas, para el caso
#de un polinomio las potencias se generan aleatoriamente un número entero entre [0,9], el peso (w) se genera 
#con una distribución uniforme entre entre [0,1] y el resto de parámetro con una distribución uniforme entre [0,9].

Terminales=['KG','KP','KS']


#Hay que tener en cuenta que por cada nivel va aumentando el número del sumatario de funciones, y que puede aumentar
#de nivel en el proceso de mutación, por lo que dejaremos los niveles iniciales en 3 para los dos.
NivelR1=5
NivelR2=5

#Generar población
n=100
poblacion=[]
arboles=[]
Errores=[]
tipoCrec=2  #crecimiento mixto

tipFuncAajustar=1  #elegir, la función a ajustar 1 -> problema 1...., 4 -> problema 4

for i in range(n):
  ind=generarIndividuo(NivelR1, NivelR2, Operadores, Terminales,tipoCrec)
  arboles.append(ind)
  funcion=generarFuncion(ind,Operadores)
  poblacion.append(funcion)

  valoresY=GenerarPtosYFunc(funcion,valXYfunc[tipFuncAajustar-1][0])
  Errores.append(darError(valXYfunc[tipFuncAajustar-1][1],valoresY,3)) #calculo errores tipo RMSE

#Selección de padres
tipSelPadres=3
#1 Selección según valor adpatación, 2 Selección por torneo, 3 Sobre selección voraz


NuevaPoblacion=[]
NuevoArboles=[]
NuevoErrores=[]

GrupoIind=[]
GrupoIArb=[]
GrupoIErrores=[]
GrupoIIind=[]
GrupoIIArb=[]
GrupoIIErrores=[]


while len(NuevaPoblacion)<n and (len(GrupoIind)+len(GrupoIIind))<n:
  if tipSelPadres==1: #Selección según valor de adpatación
    for i in range(len(poblacion)):
      if i<1:
          suma=sum(Errores)
          PorcentajeElec= [i/suma for i in Errores]

      if np.random.choice([True,False], p=[1-PorcentajeElec[i], PorcentajeElec[i]]):
        NuevaPoblacion.append(poblacion[i])
        NuevoArboles.append(arboles[i])
        NuevoErrores.append(Errores[i])
  elif tipSelPadres==2:  #Selección por torneo
    padres=random.sample(range(0, n-1), 2)
    if Errores[padres[0]]<Errores[padres[1]]:
      NuevaPoblacion.append(poblacion[padres[0]])
      NuevoArboles.append(arboles[padres[0]])
      Errores.append(Errores[padres[0]])
    elif Errores[padres[0]]>Errores[padres[1]]:
      NuevaPoblacion.append(poblacion[padres[1]])
      NuevoArboles.append(arboles[padres[1]])
      NuevoErrores.append(Errores[padres[1]]) 
    else:
      NuevaPoblacion.append(poblacion[np.random.choice(padres)])
      NuevoArboles.append(arboles[np.random.choice(padres)])
      Errores.append(Errores[np.random.choice(padres)]) 
  elif tipSelPadres==3:

    indOrdenados=np.argsort(Errores)

    if n<=1999:
      divGrp=round(n*0.32)
    elif n>=2000 and n<=3999:
      divGrp=round(n*0.16)
    elif n>=4000 and n<=7999:
      divGrp=round(n*0.08)
    else:
      divGrp=round(n*0.04)

    for i in indOrdenados:
      if i<=divGrp:
        GrupoIind.append(poblacion[i])
        GrupoIArb.append(arboles[i])
        GrupoIErrores.append(Errores[i])
      else:
        GrupoIIind.append(poblacion[i])
        GrupoIIArb.append(arboles[i])
        GrupoIIErrores.append(Errores[i])    



print(GrupoIErrores,GrupoIIErrores)
print(len(GrupoIErrores),len(GrupoIIErrores))